## 题解

要删除链表的倒数第 n 个节点，并且只进行一趟扫描，可以使用**双指针**的方法。双指针技巧能在一次遍历中找到并删除倒数第 n 个节点。下面是一个详细的步骤和代码实现。

### 解决思路

1. **设置虚拟头节点**：为了方便处理删除操作，尤其是当要删除的是第一个节点时，我们可以使用一个虚拟头节点（dummy node）来指向链表的头节点。
2. **双指针法**：初始化两个指针 `fast` 和 `slow`，都指向虚拟头节点。首先让 `fast` 指针向前移动 n 步。然后，`fast` 和 `slow` 同时向前移动，直到 `fast` 到达链表的末尾。此时，`slow` 指针将指向待删除节点的前一个节点。
3. **删除节点**：调整 `slow` 指针的 `next`，跳过待删除的节点。
4. **返回新链表的头节点**：返回虚拟头节点的 `next`，即新的链表头。

### 代码实现（C++）

```cpp
cpp复制代码#include <iostream>

// 定义链表节点结构
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0);
        dummy->next = head;

        // 初始化快慢指针
        ListNode* fast = dummy;
        ListNode* slow = dummy;

        // 将快指针向前移动 n 步
        for (int i = 0; i < n; ++i) {
            fast = fast->next;
        }

        // 快慢指针一起移动，直到快指针到达链表末尾
        while (fast->next != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }

        // 删除慢指针指向的节点的下一个节点
        slow->next = slow->next->next;

        // 返回新链表的头节点
        ListNode* newHead = dummy->next;
        delete dummy; // 删除虚拟头节点，释放内存
        return newHead;
    }
};
```

### 详细解释

1. **虚拟头节点**：
   - 创建 `dummy` 节点，目的是为了处理边界情况，例如删除第一个节点的情况。`dummy->next` 指向链表的头节点 `head`。
2. **快指针提前移动 n 步**：
   - 快指针 `fast` 先移动 n 步，这样 `fast` 与 `slow` 之间的距离就是 n。当 `fast` 到达链表末尾时，`slow` 就正好指向倒数第 n+1 个节点。
3. **双指针同步移动**：
   - 然后 `fast` 和 `slow` 指针一起移动，直到 `fast` 到达链表末尾。此时 `slow` 指向的下一个节点就是需要删除的节点。
4. **删除节点**：
   - 通过 `slow->next = slow->next->next` 跳过倒数第 n 个节点，从而将其删除。
5. **返回结果**：
   - 返回 `dummy->next`，即新的链表头节点。

### 复杂度分析

- **时间复杂度**：O(N)，其中 N 是链表的长度。只需遍历一次链表即可找到并删除节点。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

这段代码在处理链表操作时效率高且容易理解。

## 关于删除链表节点操作

在这个链表删除问题中，虽然删除的是 `slow` 指针的下一个节点，但这个操作最终导致返回的新链表是我们所需要的结果。这是因为 `slow` 指针的作用和虚拟头节点的用法相结合，确保了链表的正确性。让我们分步骤解析这个过程：

1. **双指针的使用**:
   - 两个指针 `fast` 和 `slow` 一开始都指向虚拟头节点 `dummy`。
   - `fast` 指针先向前移动 `n+1` 步，使得它与 `slow` 指针之间保持 `n` 个节点的距离。
   - 然后同时移动 `fast` 和 `slow`，直到 `fast` 指向链表的末尾。此时，`slow` 指向倒数第 `n` 个节点的前一个节点。
2. **删除节点**:
   - `slow->next = slow->next->next;` 这行代码删除了 `slow` 指针所指向节点的下一个节点，即倒数第 `n` 个节点。通过更新 `slow->next`，链表中倒数第 `n` 个节点被移除。
3. **返回新链表的头节点**:
   - 由于使用了虚拟头节点 `dummy`，即使删除的是第一个实际节点，虚拟头节点的存在也简化了边界条件的处理。
   - `ListNode* newHead = dummy->next;` 这行代码通过 `dummy->next` 返回新的链表头节点（即原始链表的第一个节点，或者第二个节点，取决于 `n` 的值）。
   - 删除虚拟头节点 `delete dummy;` 释放了分配的内存。
4. **为何返回 `newHead` 就是所需的链表**：
   - 由于 `dummy` 是虚拟头节点，它指向链表的实际起始节点，所以返回 `dummy->next` 即为删除倒数第 `n` 个节点后的链表头节点。
   - 这样，无论删除的节点是链表的中间节点还是第一个节点，都能正确处理并返回链表的头节点。

通过这个流程，尽管删除的是 `slow->next`，但是因为我们返回的是经过删除操作后链表的头节点，所以最终得到的链表就是正确的结果。

## 进一步理解这个删除操作

假设链表是 `1 -> 2 -> 3 -> 4 -> 5`，我们要删除倒数第 `2` 个节点 `4`。具体步骤如下：

1. **创建虚拟头节点**：
   - 链表变成 `dummy -> 1 -> 2 -> 3 -> 4 -> 5`，其中 `dummy` 是新增加的虚拟节点，指向原链表的头节点 `1`。
2. **找到待删除节点的前一个节点**：
   - 通过移动 `fast` 和 `slow` 指针，我们使得 `slow` 最终指向节点 `3`。
3. **执行删除操作**：
   - 这时，`slow->next` 指向要删除的节点 `4`。执行 `slow->next = slow->next->next;` 后，`slow->next` 将指向节点 `5`，从而跳过了节点 `4`。
   - 操作完成后，链表变为 `dummy -> 1 -> 2 -> 3 -> 5`。

### 为什么 `newHead` 是正确的？

1. **指针操作的影响**：
   - 通过 `slow->next = slow->next->next;`，链表中的节点 `4` 被跳过。即原来 `slow->next` 是 `4`，而现在是 `5`。
   - 虽然我们只操作了 `slow` 指针，但由于 `slow` 指向链表中节点 `3` 的地址，而该地址是链表的一部分，因此操作后整个链表结构被改变。
2. **`newHead` 指向的是 `dummy->next`**：
   - 虽然 `dummy` 是虚拟节点，但 `dummy->next` 始终指向原链表的头节点 `1`。而且，删除操作只影响了链表中的连接关系，不会改变 `dummy->next` 指向的节点。
3. **删除的效果反映在 `newHead` 上**：
   - 返回 `newHead` 后，虽然我们没有直接操作 `newHead`，但由于链表本质上是通过指针连接的节点链，操作 `slow->next` 的效果在整个链表中反映了出来。
   - 最终返回的 `newHead` 是 `1 -> 2 -> 3 -> 5`，删除了 `4`。

### 总结

`slow->next = slow->next->next;` 通过调整指针跳过了目标节点，间接改变了整个链表的结构。由于 `newHead` 指向了删除后的链表头节点，返回的链表自然是删除了目标节点后的正确结果。这种指针操作是链表操作的核心，通过修改某个节点的 `next` 指针，实现对链表结构的修改。