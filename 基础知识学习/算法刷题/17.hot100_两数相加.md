## 题解

1. **逐位相加**：从两个链表的头部开始，每一位数字相加，如果有进位则记录下来，继续加到下一位的计算中。
2. **处理链表长度不同**：如果一个链表比另一个短，则短链表视作高位补 0，继续相加。
3. **处理进位**：如果最后还有进位，需要在结果链表中再加一个节点。

### C++ 实现

```cpp
cpp复制代码#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0); // 创建一个虚拟头节点
        ListNode* curr = dummy;
        int carry = 0; // 初始化进位

        // 遍历两个链表，直到两个链表都为空
        while (l1 != nullptr || l2 != nullptr) {
            int x = (l1 != nullptr) ? l1->val : 0; // 取l1当前节点的值，若为空则为0
            int y = (l2 != nullptr) ? l2->val : 0; // 取l2当前节点的值，若为空则为0
            int sum = carry + x + y; // 计算当前位的和

            carry = sum / 10; // 计算进位
            curr->next = new ListNode(sum % 10); // 创建新节点，保存当前位结果
            curr = curr->next; // 移动指针

            // 移动l1和l2指针到下一个节点
            if (l1 != nullptr) l1 = l1->next;
            if (l2 != nullptr) l2 = l2->next;
        }

        // 如果还有进位，需要在链表末尾添加新节点
        if (carry > 0) {
            curr->next = new ListNode(carry);
        }

        return dummy->next; // 返回结果链表的头节点
    }
};
```

### 详细解释

1. **`dummy` 虚拟头节点**：
   - 使用虚拟头节点简化链表的操作。最终返回 `dummy->next` 即为结果链表。
2. **`carry` 变量**：
   - 记录每次相加的进位。如果两个数相加的和大于或等于 10，则需要产生进位。
3. **循环遍历两个链表**：
   - 每次从两个链表中取出当前节点的值相加，再加上进位，生成新的节点。
   - 当一个链表遍历完时，视作其余位补 0 处理。
4. **处理最后的进位**：
   - 如果遍历结束后仍然有进位（`carry > 0`），需要创建一个新节点存放进位。

### 示例演示

对于 `l1 = [2,4,3]` 和 `l2 = [5,6,4]`：

- 第一次循环：2 + 5 = 7（无进位），结果为 `[7]`。
- 第二次循环：4 + 6 = 10（进位 1），结果为 `[7, 0]`。
- 第三次循环：3 + 4 + 1 = 8（无进位），结果为 `[7, 0, 8]`。

最后返回 `[7,0,8]`，表示数字 807。

### 复杂度分析

- **时间复杂度**：O(max(m, n))，其中 m 和 n 分别是两个链表的长度。
- **空间复杂度**：O(max(m, n))，用于存储结果链表。

## 关于链表新建新的节点

```cpp
curr->next = new ListNode(sum % 10); // 创建新节点，保存当前位结果
curr = curr->next; // 移动指针
```

注意链表创建新的节点，要使用构造函数。

### 动态内存分配

当你通过 `new` 运算符创建一个新节点时，操作系统会从内存堆（heap）中分配一块空闲的内存给这个节点。这块内存的位置并不由程序员直接控制，而是由操作系统的内存管理机制决定的。

### 非连续内存

在链表结构中，节点在内存中的存放位置通常是非连续的。每个节点通过指针（如 `next`）来指向下一个节点，这样即使它们在内存中不连续存放，链表依然能够保持正确的顺序。

### 示例

假设内存管理器随机分配了节点的内存地址：

- 第一个节点的地址可能是 `0x0010`。
- 第二个节点可能在 `0x1000`。
- 第三个节点可能在 `0x00A0`。

尽管地址分配看似随机，但通过 `next` 指针，链表依然能够连接这些节点。每个节点的 `next` 指针保存着下一个节点的地址，从而实现了链表的有序连接。

### 总结

虽然节点的内存地址是由系统随机分配的，但由于 `next` 指针明确指向下一个节点的位置，链表能够有效地管理和操作这些节点，即使它们在内存中是非连续的。